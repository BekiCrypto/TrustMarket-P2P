/**
 * @file Firestore Security Rules for P2P TrustMarket
 * @core_philosophy This ruleset enforces a strict user-ownership model for user profiles and listings,
 *  and a shared-access model for trades and disputes, leveraging denormalized fields for efficient authorization.
 *  Escrow contracts have minimal security.
 * @data_structure
 * - /users/{userId}: User profiles, owned by the user.
 * - /users/{userId}/listings/{listingId}: Listings created by a specific user, owned by the user.
 * - /trades/{tradeId}: Trades between two users.
 * - /escrowContracts/{escrowContractId}: Escrow contract details.
 * - /disputes/{disputeId}: Disputes between users in a trade.
 * @key_security_decisions
 * - Users can only access their own profile data.
 * - Users can only manage their own listings.
 * - Trades are accessible to the buyer and seller.
 * - Disputes are accessible to the filer, buyer, and seller of the related trade.
 * - Listing of users is disallowed.
 * @denormalization_for_authorization
 * - Listings denormalize `sellerId` to enable ownership checks without additional reads.
 * - Trades denormalize `buyerId` and `sellerId` to enable participation checks without additional reads.
 * - Disputes denormalize `filerId` and implicitly include `buyerId` and `sellerId` via the trade, enabling participation checks without additional reads.
 * @structural_segregation User data and listings are stored under the /users/{userId} path, enforcing ownership.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Enforces access control for user profiles, allowing users to read and write their own data.
     * @path /users/{userId}
     * @allow (create) User with ID 'user_abc' can create their own profile.
     *   Request: { auth: { uid: 'user_abc' }, resource.data.id: 'user_abc' }
     * @allow (get, update, delete) User with ID 'user_abc' can read/update/delete their own profile.
     *   Request: { auth: { uid: 'user_abc' } }
     * @deny (create) User with ID 'user_abc' cannot create a profile for another user 'user_xyz'.
     *   Request: { auth: { uid: 'user_abc' }, resource.data.id: 'user_xyz' }
     * @deny (get, update, delete) User with ID 'user_xyz' cannot read/update/delete the profile of user 'user_abc'.
     *   Request: { auth: { uid: 'user_xyz' } }
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && exists(resource);
      }

      allow get: if isSignedIn() && isOwner(userId);
      allow list: if false;
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.id == request.auth.uid;
      allow update: if isExistingOwner(userId) && isOwner(userId);
      allow delete: if isExistingOwner(userId) && isOwner(userId);
    }

    /**
     * @description Enforces access control for listings, allowing users to manage their own listings.
     * @path /users/{userId}/listings/{listingId}
     * @allow (create) User 'user_abc' can create a listing under their profile.
     *   Request: { auth: { uid: 'user_abc' }, resource.data.sellerId: 'user_abc' }
     * @allow (get, update, delete) User 'user_abc' can read/update/delete their own listing.
     *   Request: { auth: { uid: 'user_abc' }, resource.data.sellerId: 'user_abc' }
     * @deny (create) User 'user_abc' cannot create a listing for another user 'user_xyz'.
     *   Request: { auth: { uid: 'user_abc' }, resource.data.sellerId: 'user_xyz' }
     * @deny (get, update, delete) User 'user_xyz' cannot read/update/delete a listing owned by user 'user_abc'.
     *   Request: { auth: { uid: 'user_xyz' }, resource.data.sellerId: 'user_abc' }
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/listings/{listingId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && exists(resource);
      }

      allow get: if isSignedIn() && isOwner(userId);
      allow list: if false;
      allow create: if isSignedIn() && request.auth.uid == userId;
      allow update: if isExistingOwner(userId) && request.auth.uid == userId;
      allow delete: if isExistingOwner(userId) && request.auth.uid == userId;
    }

    /**
     * @description Enforces access control for trades, allowing participants (buyer and seller) to read trade details.
     * @path /trades/{tradeId}
     * @allow (get) Buyer 'user_abc' can get trade where they are the buyer.
     *   Request: { auth: { uid: 'user_abc' }, resource.data.buyerId: 'user_abc' }
     * @allow (get) Seller 'user_xyz' can get trade where they are the seller.
     *   Request: { auth: { uid: 'user_xyz' }, resource.data.sellerId: 'user_xyz' }
     * @deny (get) User 'user_def' cannot get trade where they are neither the buyer nor the seller.
     *   Request: { auth: { uid: 'user_def' }, resource.data.buyerId: 'user_abc', resource.data.sellerId: 'user_xyz' }
     * @principle Enforces shared access for trades, based on participation.
     */
    match /trades/{tradeId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isBuyerOrSeller(buyerId, sellerId) {
        return request.auth.uid == buyerId || request.auth.uid == sellerId;
      }

      allow get: if isSignedIn() && (resource.data.buyerId == request.auth.uid || resource.data.sellerId == request.auth.uid);
      allow list: if false;
      allow create: if isSignedIn();
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Enforces access control for escrow contracts, allowing public read access. Write access is disabled.
     * @path /escrowContracts/{escrowContractId}
     * @allow (get, list) Any user can read escrow contract details.
     *   Request: { auth: { uid: 'user_abc' } }
     * @deny (create, update, delete) No user can create, update, or delete escrow contracts.
     *   Request: { auth: { uid: 'user_abc' } }
     * @principle Allows public read access with restricted write access.
     */
    match /escrowContracts/{escrowContractId} {
      allow get: if true;
      allow list: if false;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Enforces access control for disputes, allowing participants (filer, buyer, and seller) to read dispute details.
     * @path /disputes/{disputeId}
     * @allow (get) Filer 'user_abc' can get dispute they filed.
     *   Request: { auth: { uid: 'user_abc' }, resource.data.filerId: 'user_abc' }
     * @allow (get) Buyer 'user_xyz' can get dispute related to a trade they are a buyer in.
     *   Request: { auth: { uid: 'user_xyz' }, resource.data.trade.buyerId: 'user_xyz' }
     * @allow (get) Seller 'user_def' can get dispute related to a trade they are a seller in.
     *   Request: { auth: { uid: 'user_def' }, resource.data.trade.sellerId: 'user_def' }
     * @deny (get) User 'user_ghi' cannot get dispute where they are not the filer, buyer, or seller.
     *   Request: { auth: { uid: 'user_ghi' }, resource.data.filerId: 'user_abc', resource.data.trade.buyerId: 'user_xyz', resource.data.trade.sellerId: 'user_def' }
     * @principle Enforces shared access for disputes, based on participation.
     */
    match /disputes/{disputeId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isFiler(filerId) {
        return request.auth.uid == filerId;
      }

       // TODO: Implement isBuyerOrSeller using a get() call to the /trades/{tradeId} document
       // The current rule requires denormalized trade data on the dispute document to check buyer/seller access
       // This is insecure because it trusts client-provided data.

      allow get: if isSignedIn() && resource.data.filerId == request.auth.uid;
      allow list: if false;
      allow create: if isSignedIn();
      allow update: if false;
      allow delete: if false;
    }
  }
}