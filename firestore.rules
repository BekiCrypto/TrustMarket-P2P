/**
 * @fileoverview Firestore Security Rules for the P2P TrustMarket platform.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for user profiles and listings, and a collaborative access model for trades and disputes.
 * All write operations are guarded by authentication checks and ownership/membership validation.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profiles, accessible only by the user themselves.
 * - /users/{userId}/listings/{listingId}: Stores listings created by a specific user, accessible only by the user.
 * - /trades/{tradeId}: Stores trade data, accessible to the buyer and seller involved.
 * - /escrowContracts/{escrowContractId}: Stores escrow contract details. Access is not explicitly restricted in this prototype.
 * - /disputes/{disputeId}: Stores dispute data, accessible to the filer, buyer, and seller involved in the trade.
 *
 * Key Security Decisions:
 * - User listing is disallowed.
 * - Escrow contracts have open access for now. This should be reviewed and restricted in later iterations.
 * - Data validation is minimal in this prototype phase, focusing on authorization-critical fields.
 *
 * Denormalization for Authorization:
 * - Listings include `sellerId` for owner-based access control.
 * - Trades include `buyerId` and `sellerId` for participant-based access control.
 * - Disputes include `filerId` and inherit `buyerId` and `sellerId` from the associated trade for access control.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Allows a user to read and write their own profile data.
     * @path /users/{userId}
     * @allow (create) User with id 'user123' can create their profile.
     *   request.auth.uid == 'user123' && request.resource.data.id == 'user123'
     * @allow (get) User with id 'user123' can read their profile.
     *   request.auth.uid == 'user123'
     * @allow (update) User with id 'user123' can update their profile.
     *   request.auth.uid == 'user123'
     * @deny (create) User with id 'user123' cannot create a profile with id 'user456'.
     *   request.auth.uid == 'user123' && request.resource.data.id == 'user456'
     * @deny (get) User with id 'user456' cannot read the profile of user 'user123'.
     *   request.auth.uid == 'user456'
     * @deny (update) User with id 'user456' cannot update the profile of user 'user123'.
     *   request.auth.uid == 'user456'
     * @principle Enforces document ownership for writes and reads.
     */
    match /users/{userId} {
      //  Functions
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return isSignedIn() && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
          return isOwner(userId) && exists(resource);
      }

      // Permissions
      allow get: if isOwner(userId);
      allow list: if false;

      allow create: if isOwner(userId) && request.resource.data.id == request.auth.uid;
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Allows a user to create, read, update and delete their own listings.
     * @path /users/{userId}/listings/{listingId}
     * @allow (create) User with id 'user123' can create a listing under their profile.
     *   request.auth.uid == 'user123' && request.resource.data.sellerId == 'user123'
     * @allow (get) User with id 'user123' can read their own listing.
     *   request.auth.uid == 'user123'
     * @allow (update) User with id 'user123' can update their own listing.
     *   request.auth.uid == 'user123'
     * @deny (create) User with id 'user123' cannot create a listing for user 'user456'.
     *   request.auth.uid == 'user123' && request.resource.data.sellerId == 'user456'
     * @deny (get) User with id 'user456' cannot read a listing belonging to user 'user123'.
     *   request.auth.uid == 'user456'
     * @deny (update) User with id 'user456' cannot update a listing belonging to user 'user123'.
     *   request.auth.uid == 'user456'
     * @principle Enforces document ownership for writes and reads within a user's subcollection.
     */
    match /users/{userId}/listings/{listingId} {
      //  Functions
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return isSignedIn() && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
          return isOwner(userId) && exists(resource);
      }

      // Permissions
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);

      allow create: if isSignedIn() && request.auth.uid == userId && request.resource.data.sellerId == userId;
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Allows the buyer and seller involved in a trade to read trade data and restricts write access.
     * @path /trades/{tradeId}
     * @allow (get) User with id 'user123' can read a trade where they are the buyer or seller.
     *   request.auth.uid == 'user123'
     * @deny (create) User with id 'user123' cannot create a trade without being the buyer or seller.
     *   request.auth.uid == 'user123'
     * @deny (update) User with id 'user456' cannot update a trade where they are not the buyer or seller.
     *   request.auth.uid == 'user456'
     * @deny (delete) User with id 'user456' cannot delete a trade where they are not the buyer or seller.
     *   request.auth.uid == 'user456'
     * @principle Enforces shared access based on buyer and seller roles.
     */
    match /trades/{tradeId} {
      //  Functions
      function isSignedIn() {
        return request.auth != null;
      }

      function isParticipant(buyerId, sellerId) {
        return isSignedIn() && (request.auth.uid == buyerId || request.auth.uid == sellerId);
      }

      function isExistingParticipant(buyerId, sellerId) {
          return isParticipant(buyerId, sellerId) && exists(resource);
      }

      // Permissions
      allow get: if isSignedIn() && (resource.data.buyerId == request.auth.uid || resource.data.sellerId == request.auth.uid);
      allow list: if false;

      allow create: if isSignedIn() && (request.resource.data.buyerId == request.auth.uid || request.resource.data.sellerId == request.auth.uid);
      allow update: if isSignedIn() && (resource.data.buyerId == request.auth.uid || resource.data.sellerId == request.auth.uid);
      allow delete: if isSignedIn() && (resource.data.buyerId == request.auth.uid || resource.data.sellerId == request.auth.uid);
    }

    /**
     * @description Allows anyone to read escrow contract data. Write permissions are disabled in this prototype.
     * @path /escrowContracts/{escrowContractId}
     * @allow (get) Any user can read escrow contract data.
     *   true
     * @deny (create) No user can create escrow contract data.
     *   false
     * @deny (update) No user can update escrow contract data.
     *   false
     * @deny (delete) No user can delete escrow contract data.
     *   false
     * @principle Public read access with no write access (for now).
     */
    match /escrowContracts/{escrowContractId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    /**
     * @description Allows the filer, buyer, and seller involved in a trade to read dispute data and restricts write access.
     * @path /disputes/{disputeId}
     * @allow (get) User with id 'user123' can read a dispute where they are the filer, buyer, or seller.
     *   request.auth.uid == 'user123'
     * @deny (create) User with id 'user123' cannot create a dispute without being the filer, buyer, or seller.
     *   request.auth.uid == 'user123'
     * @deny (update) User with id 'user456' cannot update a dispute where they are not the filer, buyer, or seller.
     *   request.auth.uid == 'user456'
     * @deny (delete) User with id 'user456' cannot delete a dispute where they are not the filer, buyer, or seller.
     *   request.auth.uid == 'user456'
     * @principle Enforces shared access based on filer, buyer, and seller roles.
     */
    match /disputes/{disputeId} {
      //  Functions
      function isSignedIn() {
        return request.auth != null;
      }

      function getTrade(tradeId) {
        return get(/databases/$(database)/documents/trades/$(tradeId));
      }

      function isParticipant(dispute, trade) {
        return isSignedIn() && (request.auth.uid == dispute.filerId || request.auth.uid == trade.data.buyerId || request.auth.uid == trade.data.sellerId);
      }

      function isExistingParticipant(dispute, trade) {
          return isParticipant(dispute, trade) && exists(resource);
      }

      // Permissions
      allow get: if isSignedIn() && let trade = getTrade(resource.data.tradeId);
                  then trade.data.buyerId == request.auth.uid || trade.data.sellerId == request.auth.uid || resource.data.filerId == request.auth.uid;
      allow list: if false;

      allow create: if isSignedIn() && let trade = getTrade(request.resource.data.tradeId);
                  then trade.data.buyerId == request.auth.uid || trade.data.sellerId == request.auth.uid || request.resource.data.filerId == request.auth.uid;
      allow update: if false; // TODO: Add condition to allow only arbitrator to update
      allow delete: if false;
    }
  }
}